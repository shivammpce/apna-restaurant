// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: orders.sql

package repo

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const checkExistingOrder = `-- name: CheckExistingOrder :one
SELECT COUNT(*) AS order_count
FROM orders
WHERE id = $1
`

func (q *Queries) CheckExistingOrder(ctx context.Context, id uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.checkExistingOrderStmt, checkExistingOrder, id)
	var order_count int64
	err := row.Scan(&order_count)
	return order_count, err
}

const checkExistingTable = `-- name: CheckExistingTable :one
SELECT COUNT(*) AS table_count
FROM tables
WHERE id = $1
`

func (q *Queries) CheckExistingTable(ctx context.Context, id uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.checkExistingTableStmt, checkExistingTable, id)
	var table_count int64
	err := row.Scan(&table_count)
	return table_count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    table_id, amount, order_items
) VALUES (
    $1, $2, $3
)
RETURNING id, table_id, amount, order_items, created_at, delivered_at
`

type CreateOrderParams struct {
	TableID    uuid.UUID             `json:"table_id"`
	Amount     sql.NullInt32         `json:"amount"`
	OrderItems pqtype.NullRawMessage `json:"order_items"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.queryRow(ctx, q.createOrderStmt, createOrder, arg.TableID, arg.Amount, arg.OrderItems)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.Amount,
		&i.OrderItems,
		&i.CreatedAt,
		&i.DeliveredAt,
	)
	return i, err
}

const createTable = `-- name: CreateTable :one
WITH inserted AS (
    INSERT INTO tables (table_number, order_ids)
    VALUES (
        $1,
        (SELECT ARRAY[$2::UUID])
    )
    RETURNING id
)
SELECT id, $1 AS table_number, $2 AS order_ids
FROM inserted
`

type CreateTableParams struct {
	TableNumber int32       `json:"table_number"`
	OrderIds    []uuid.UUID `json:"order_ids"`
}

type CreateTableRow struct {
	ID          uuid.UUID   `json:"id"`
	TableNumber interface{} `json:"table_number"`
	OrderIds    interface{} `json:"order_ids"`
}

func (q *Queries) CreateTable(ctx context.Context, arg CreateTableParams) (CreateTableRow, error) {
	row := q.queryRow(ctx, q.createTableStmt, createTable, arg.TableNumber, pq.Array(arg.OrderIds))
	var i CreateTableRow
	err := row.Scan(&i.ID, &i.TableNumber, &i.OrderIds)
	return i, err
}

const deleteOrderByID = `-- name: DeleteOrderByID :exec
DELETE FROM orders
WHERE id = $1
`

func (q *Queries) DeleteOrderByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteOrderByIDStmt, deleteOrderByID, id)
	return err
}

const deleteTableByID = `-- name: DeleteTableByID :exec
DELETE FROM tables
WHERE id = $1
`

func (q *Queries) DeleteTableByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteTableByIDStmt, deleteTableByID, id)
	return err
}

const getAllOrders = `-- name: GetAllOrders :many
SELECT id, table_id, amount, order_items, created_at, delivered_at FROM orders
ORDER BY created_at
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.query(ctx, q.getAllOrdersStmt, getAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TableID,
			&i.Amount,
			&i.OrderItems,
			&i.CreatedAt,
			&i.DeliveredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTables = `-- name: GetAllTables :many
SELECT id, table_number, order_ids FROM tables ORDER BY id
`

func (q *Queries) GetAllTables(ctx context.Context) ([]Table, error) {
	rows, err := q.query(ctx, q.getAllTablesStmt, getAllTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Table
	for rows.Next() {
		var i Table
		if err := rows.Scan(&i.ID, &i.TableNumber, pq.Array(&i.OrderIds)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, table_id, amount, order_items, created_at, delivered_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.queryRow(ctx, q.getOrderByIDStmt, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.Amount,
		&i.OrderItems,
		&i.CreatedAt,
		&i.DeliveredAt,
	)
	return i, err
}

const getTableByID = `-- name: GetTableByID :one
SELECT id, table_number, order_ids FROM tables WHERE id = $1
`

func (q *Queries) GetTableByID(ctx context.Context, id uuid.UUID) (Table, error) {
	row := q.queryRow(ctx, q.getTableByIDStmt, getTableByID, id)
	var i Table
	err := row.Scan(&i.ID, &i.TableNumber, pq.Array(&i.OrderIds))
	return i, err
}

const removeOrderIDFromTables = `-- name: RemoveOrderIDFromTables :exec
UPDATE tables
SET order_ids = array_remove(order_ids, $1)
WHERE $1 = ANY(order_ids)
`

func (q *Queries) RemoveOrderIDFromTables(ctx context.Context, arrayRemove interface{}) error {
	_, err := q.exec(ctx, q.removeOrderIDFromTablesStmt, removeOrderIDFromTables, arrayRemove)
	return err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET
    table_id = $1,
    amount = $2,
    order_items = $3,
    created_at = $4, 
    delivered_at = $5
WHERE
    id = $6
RETURNING id, table_id, amount, order_items, created_at, delivered_at
`

type UpdateOrderParams struct {
	TableID     uuid.UUID             `json:"table_id"`
	Amount      sql.NullInt32         `json:"amount"`
	OrderItems  pqtype.NullRawMessage `json:"order_items"`
	CreatedAt   time.Time             `json:"created_at"`
	DeliveredAt sql.NullTime          `json:"delivered_at"`
	ID          uuid.UUID             `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.queryRow(ctx, q.updateOrderStmt, updateOrder,
		arg.TableID,
		arg.Amount,
		arg.OrderItems,
		arg.CreatedAt,
		arg.DeliveredAt,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TableID,
		&i.Amount,
		&i.OrderItems,
		&i.CreatedAt,
		&i.DeliveredAt,
	)
	return i, err
}

const updateTable = `-- name: UpdateTable :one
UPDATE tables
SET
    table_number = $1,
    order_ids = $2
WHERE
    id = $3
RETURNING id, table_number, order_ids
`

type UpdateTableParams struct {
	TableNumber int32       `json:"table_number"`
	OrderIds    []uuid.UUID `json:"order_ids"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateTable(ctx context.Context, arg UpdateTableParams) (Table, error) {
	row := q.queryRow(ctx, q.updateTableStmt, updateTable, arg.TableNumber, pq.Array(arg.OrderIds), arg.ID)
	var i Table
	err := row.Scan(&i.ID, &i.TableNumber, pq.Array(&i.OrderIds))
	return i, err
}
